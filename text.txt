// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GridStation {
    address public gridStationAddress;
    uint256 public totalSoldToGrid;
    uint256 public totalBoughtFromGrid;

    uint256 public constant sellUnitsToGridPrice = 100 wei; // per unit
    uint256 public constant buyUnitsFromGridPrice = 50 wei; // per unit

    struct HouseRecord {
        uint256 totalUnitsSold;
        uint256 unitsSoldButNotPaid;
    }
    receive() external payable {}
    mapping(address => HouseRecord) public houseRecords;

    function sellUnitsToGrid(uint256 _units) external payable {
        uint256 amountToPay = _units * sellUnitsToGridPrice;
        require(
            address(this).balance >= amountToPay,
            "Grid station does not have enough funds"
        );

        totalSoldToGrid += _units;
        houseRecords[msg.sender].totalUnitsSold += _units;
        houseRecords[msg.sender].unitsSoldButNotPaid += _units;
        if (houseRecords[msg.sender].unitsSoldButNotPaid >= 20) {
            payHouse(msg.sender);
        }
    }

    function getHouseRecord() external view returns (HouseRecord memory) {
        return houseRecords[msg.sender];
    }

    function buyUnitsFromGrid(uint256 _units) external payable {
        uint256 totalPrice = _units * buyUnitsFromGridPrice;
        require(msg.value >= totalPrice, "Insufficient payment");

        totalSoldToGrid -= _units;
        totalBoughtFromGrid += _units;

        // If there's excess ether sent by the caller, refund it
        uint256 excessAmount = msg.value - totalPrice;
        if (excessAmount > 0) {
            payable(msg.sender).transfer(excessAmount);
        }
    }

    function payHouse(address _houseOwner) private {
        uint256 amountToPay = houseRecords[_houseOwner].unitsSoldButNotPaid *
            sellUnitsToGridPrice;
        payable(_houseOwner).transfer(amountToPay);
        houseRecords[_houseOwner].unitsSoldButNotPaid = 0;
    }
}


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./GridStation.sol";

contract House {
    struct HouseInfo {
        string houseName;
        string houseAddress;
        uint256 houseId;
        uint256 energyProduction;
        uint256 energyConsumption;
        address houseOwner;
        address gridStation;
    }
    receive() external payable {}
    mapping(uint256 => HouseInfo) public houses;
    uint256 public houseCount;

    // Event to emit when energy is bought or sold
    event EnergyTransaction(
        address indexed from,
        address indexed to,
        uint256 units
    );

    // Method to add a new house
    function addHouse(
        string memory _houseName,
        string memory _houseAddress,
        address _gridStation
    ) external {
        houseCount++;
        houses[houseCount] = HouseInfo(
            _houseName,
            _houseAddress,
            houseCount,
            0,
            0,
            msg.sender,
            _gridStation
        );
    }

    // Method to get all houses
    function getAllHouses() external view returns (HouseInfo[] memory) {
        HouseInfo[] memory allHouses = new HouseInfo[](houseCount);
        for (uint256 i = 1; i <= houseCount; i++) {
            allHouses[i - 1] = houses[i];
        }
        return allHouses;
    }

    // Method to get house by ID
    function getHouseById(
        uint256 _houseId
    ) external view returns (HouseInfo memory) {
        return houses[_houseId];
    }

    // Method to update energy production for a house
    function updateEnergyProduction(
        uint256 _houseId,
        uint256 _newProduction
    ) external {
        require(_houseId <= houseCount, "Invalid House ID");
        houses[_houseId].energyProduction = _newProduction;
    }

    // Method to update energy consumption for a house
    function updateEnergyConsumption(
        uint256 _houseId,
        uint256 _newConsumption
    ) external {
        require(_houseId <= houseCount, "Invalid House ID");
        houses[_houseId].energyConsumption = _newConsumption;
    }
}
